# 毕业总结
时间飞快，一转眼算法训练营就结束了。开篇的时候，超哥两个提醒让人印象深刻，一个是到了第四周的时候会变得困难，另一个是要全身心投入。对于第一个，果然是这样，一来是题目进入平时没有接触过，另一个需要重新学习新的思维。对于第二个，要在平时忙碌的工作中保持全身心投入确实很困难。虽然如此，但是还是收获了很多。    
收获：首先跟着超哥系统的学习了算法。无论是之前大学的学习，还是后来自己看书都没法把握住算法的方向，总是刷刷停停，不得要领。超哥的以leetcode为主，各个层次学习，让人握住脉络，可以循序渐进的联系。第二就是超哥多次提醒刷题是个不断重复的过程。学习中不仅教授解题技巧，更教授刷题的本质是刷这种本质方法。
最后感谢覃超老师，两位助教，感谢班班，各位同学。

# 毕业刷题路线
课程主要分为13个小节学习：    
- 1.数组、链表、跳表    
- 2.栈、队列、优先队列、双端队列        
- 3.哈希表、映射、集合    
- 4.树、二叉树、二叉搜索树    
- 5.堆、二叉堆、图    
- 6.递归、分支、回溯    
- 7.深度优先、广度优先    
- 8.贪心、二分查找    
- 9.动态规划    
- 10.并查集、字典树、红黑树、AVL树    
- 11.位运算、布隆过滤器、LRU    
- 12.排序    
- 13.字符串       
## 1. 数组、链表、跳表    
#### 数组
1.习题
- [移动零](https://leetcode-cn.com/problems/move-zeroes/)
- [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
- [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
- [两数之和](https://leetcode-cn.com/problems/two-sum/)
- [三数之和](https://leetcode-cn.com/problems/3sum/)        

2.技巧

遍历：基础搜索数组方法，注意i的起始位置
```
for i := 0; i < len(nums); i++ {
    // 遍历
}
```
放置法：将符合条件的元素放到合适的位置，注意pos的累加
```
【移动零】
pos := 0
for i := 0; i < len(nums); i++ {
    if nums[i] != 0 {
        if i > pos { // 减少重复元素的交换
            nums[pos], nums[i] = nums[i], nums[pos]
        }
        pos++
    }
}

【爬楼梯】用于存储数据
dp := make([]int, n)
// 初始数据
dp[0] = 1
dp[1] = 2
// 递推
for i := 2; i < n; i++ {
    dp[i] = dp[i-1]+dp[i-2]
}
return dp[n-1]

```
双指针法：首位指针同步移动,注意重复元素的处理和数组有序
```
【三数之和】
head := i + 1
tail := len(nums) - 1

for head < tail {
    if nums[head]+nums[tail]+nums[i] == 0 {
        // 添加
        resArr = append(resArr, []int{nums[head], nums[tail], nums[i]})
        // 处理左重复逻辑
        for head < tail && nums[head] == nums[head+1] {
            head++
        }
        for head < tail && nums[tail] == nums[tail-1] {
            tail--
        }
        head++
        tail--
    } else if nums[head]+nums[tail]+nums[i] > 0 {
        tail--
    } else {
        head++
    }
}

【盛最多水】
begin := 0
end := len(height) - 1
res := 0
for begin < end {
    res = max(res, (end-begin)*min(height[begin], height[end]))
    // 左右移动得到的底是相同的，因此小的寻求更大的机会
    if height[begin] > height[end] {
        end--
    } else {
        begin++
    }
}
```

#### 链表
1.习题
- [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
- [两两交换链表节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs//)
- [链表有环](https://leetcode-cn.com/problems/linked-list-cycle/)
- [链表有环2](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
- [k个一组反转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

2.技巧

遍历：基础搜索链表方法，判断是否为空
```
curr := head
for curr != nil {
    curr := curr.Next
}
```
定位指针：先保留next指针，避免丢失
```
【反转链表】
var pre *ListNode
curr := head
for curr != nil {
    // 	curr.Next, pre, curr = pre, curr, curr.Next
    tmp := curr.Next
    // 核心做了反向
    curr.Next = pre
    // 后面两个做了移动
    pre = curr
    curr = tmp
}
return pre

【成对反转链表】前置指针设置、定位指针的设置
dummy := &ListNode{}
dummy.Next = head
// 必须要有一个前置节点，否则交换的时候无法找到前置节点
pre := dummy
for pre.Next != nil && pre.Next.Next != nil {
    first := pre.Next
    second := pre.Next.Next
    // 前面连接
    pre.Next = second
    // 简化为second.Next, first.Next = first, second.Next
    tmp := second.Next
    second.Next = first
    first.Next = tmp
    // 移动
    pre = first // 这个地方得用first作为前置，因为经过上面交换这个变成了下一组的前置节点 移动
}
```
递归：移动递归
```
【反转】
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	curr := reverseList(head.Next)

	head.Next.Next = head
	head.Next = nil
	return curr
}

【成对反转】
func swapPairs(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	// 将当前给next，并最终返回next
	next := head.Next
	// head连接下一组
	head.Next = swapPairs(next.Next)
	// next指向head
	next.Next = head
	return next
}

```
快慢指针：速度判断环
```
【链表有环】
slow := head
fast := head.Next
for fast.Next != nil && fast.Next.Next != nil {
    if fast == slow {
        return true
    }
    slow = slow.Next
    fast = fast.Next.Next
}
return false
```
#### 跳表
理解跳表的多层，以及多次删除后需要重新设置，维护成本等问题

## 2.栈、队列、优先队列、双端队列    
#### 栈
1.习题
- [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
- [最小栈](https://leetcode-cn.com/problems/min-stack/)
- [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
- [柱状图中最大矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

2.技巧

左进右出：左进栈，遇右出栈，对比
```
【验证括号】
for _, val := range s {
    str := string(rune(val))
    if str == "(" || str == "[" || str == "{" {
        stack.Push(str)
    } else {
        if _, ok := parentMap[str]; !ok {
            return false
        }
        top := stack.Pop()
        if top != parentMap[str] {
            return false
        }
    }
}
if len(stack) > 0 {
    return false
}
return true
```

累计对比：走过的路，不用回头
```
【接雨水】用栈保留最大的高度
ans := 0
stack := StackInt{}
for i := 0; i < len(height); i++ {
    // 上升则开始计算水面积
    for false == stack.IsEmpty() && height[i] > height[stack.Top()] {
        top := stack.Top()
        // 弹出为了找到上上一个下降点进行对比
        stack.Pop()
        if stack.IsEmpty() {
            break
        }
        // 当前到上上一个的下降点的举例
        distance := i - stack.Top() - 1
        // 当前和上上一个下降点与上一个下降点的差值
        boundedHeight := min(height[i], height[stack.Top()]) - height[top]
        ans += distance * boundedHeight
    }
    stack.Push(i)
}
return ans
```
#### 队列
1.习题
- [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

2.技巧

滑动窗口：计数控制，记录索引
```
【滑动窗口最大值】
resultArr := make([]int, 0, len(nums)-1)
dequeue := list.New()
for i := 0; i < len(nums); i++ {
    // 超员则删除老大
    if dequeue.Len() > 0 && i-k >= dequeue.Front().Value.(int) {
        dequeue.Remove(dequeue.Front())
    }
    // pk队列内，干掉小的
    for dequeue.Len() > 0 && nums[i] > nums[dequeue.Back().Value.(int)] {
        dequeue.Remove(dequeue.Back())
    }
    // 加入队列
    dequeue.PushBack(i)

    // 满员后，一直给出老大
    if i >= k-1 {
        resultArr = append(resultArr, nums[dequeue.Front().Value.(int)])
    }
}
```
层级数据：计数控制，使用层级数据
```
【树的层级获取】
queue := TreeNodeQueue{}
queue.push(root)
for queue.size() > 0 {
    size := queue.size()
    maxInt := math.MinInt32
    for size > 0 {
        node := queue.pop()
        size--
        maxInt = max(maxInt, node.Val)
        if node.Left != nil {
            queue.push(node.Left)
        }
        if node.Right != nil {
            queue.push(node.Right)
        }

    }
    res = append(res, maxInt)
}
```

#### 优先队列和双端队列


## 3.哈希表、映射、集合    
### 映射
1.习题
- [有效字母异位](https://leetcode-cn.com/problems/valid-anagram/description/)
- [字母异位分组](https://leetcode-cn.com/problems/group-anagrams/)
- [两数之和](https://leetcode-cn.com/problems/two-sum/)

2.技巧
map累加法：判断存在以及存在多个
```
【有效字母异位】
for i, _ := range s {
    if _, ok := strMap[s[i]]; ok {
        strMap[s[i]]++
    } else {
        strMap[s[i]] = 1
    }
}
【两数之和】
numMap := make(map[int]int)
for i, num := range nums {
    // 只对应一个答案
    if _, ok := numMap[target-num]; ok {
        return []int{i, numMap[target-num]}
    }
    numMap[num] = i
}
```

## 4.树、二叉树、二叉搜索树    
### 二叉树
1.习题
- [二叉树的前、中、后序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
- [二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

2.技巧

递归：指针靠递归
```
【前序遍历】
func preorderTraversal(root *TreeNode) []int {
	res := []int{}
	if root == nil {
		return nil
	}
	res = append(res, root.Val)
	res = append(res, preorderTraversal(root.Left)...)
	res = append(res, preorderTraversal(root.Right)...)
	return res
}
```
栈：
```
【前序遍历】
func preorderTraversal1(root *TreeNode) []int {
	if root == nil {
		return []int{}
	}
    res := []int{}
	stack := StackTreeNode([]*TreeNode{root}) 
	for false == stack.IsEmpty() {
		cur := stack.Pop()
		res = append(res, cur.Val)

		if cur.Right != nil {
			stack.Push(cur.Right)
		}
		if cur.Left != nil {
			stack.Push(cur.Left)
		}
	}
	return res
}
```
队列：
```
【N叉树的层次遍历】
func levelOrder(root *TreeNode) [][]int {
	res := make([][]int, 0)
	if root == nil {
		return res
	}
	queue := TreeNodeQueue{}
	queue.push(root)

	for queue.size() > 0 {
		size := queue.size()
		curLevel := make([]int, 0, size)
		for size > 0 {
			cur := queue.pop()
			if cur.Left != nil {
				queue.push(cur.Left)
			}
			if cur.Right != nil {
				queue.push(cur.Right)
			}
			curLevel = append(curLevel, cur.Val)
			size--
		}
		res = append(res, curLevel)
	}
	return res
}
```

## 5.堆、二叉堆、图    
#### 堆
1.习题
- [最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
- [丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

2.技巧
大顶堆：求最小用大顶堆，求最大用小顶堆
```
【最小的k个数】
// 堆 求小数 大顶堆
func getLeastNumbers(arr []int, k int) []int {
	if k == 0 || k > len(arr) {
		return []int{}
	}
	h := &intMaxHeap{}
	heap.Init(h)
	for _, v := range arr {
		heap.Push(h, v)
		if h.Len() > k {
			heap.Pop(h)
		}
	}

	res := []int{}
	for h.Len() > 0 {
		res = append(res, heap.Pop(h).(int))
	}
	return res
}
【丑数】
func nthUglyNumber(n int) int {
	uglyNum := 0
	h := intMinHeap{}
	heap.Init(&h)
	heap.Push(&h, 1)
	for n > 0 {
		for h[0] == uglyNum {
			heap.Pop(&h)
		}
		uglyNum = heap.Pop(&h).(int)
		// 将后面的丑数加入堆
		for _, num := range []int{2, 3, 5} {
			if num*uglyNum <= math.MaxInt32 {
				heap.Push(&h, num*uglyNum)
			}
		}
		n--
	}
	return uglyNum
}
【前k个高频元素】
func topKFrequent(nums []int, k int) []int {
	numMap := make(map[int]int)
	for _, num := range nums {
		numMap[num]++
	}
	h := &IHeap{}
	heap.Init(h)
	// 小顶堆
	for key, value := range numMap {
		heap.Push(h, [2]int{key, value})
		if h.Len() > k {
			heap.Pop(h)
		}
	}
	ret := make([]int, h.Len())
	// 正序排列
	for i := 0; i < k; i++ {
		ret[i] = heap.Pop(h).([2]int)[0]
	}
	return ret
}
```
